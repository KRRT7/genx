<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>genx.models package &mdash; GenX 2.2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/genx.ico"/>
    <link rel="top" title="GenX 2.2.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">GenX 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/genx_sidebar.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">genx.models package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-genx.models.interdiff">genx.models.interdiff module</a></li>
<li><a class="reference internal" href="#module-genx.models.mag_refl">genx.models.mag_refl module</a></li>
<li><a class="reference internal" href="#module-genx.models.spec_nx">genx.models.spec_nx module</a></li>
<li><a class="reference internal" href="#module-genx.models.sxrd">genx.models.sxrd module</a></li>
<li><a class="reference internal" href="#module-genx.models.sxrd_mult">genx.models.sxrd_mult module</a></li>
<li><a class="reference internal" href="#module-genx.models.utils">genx.models.utils module</a></li>
<li><a class="reference internal" href="#module-genx.models">Module contents</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/genx.models.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="genx-models-package">
<h1>genx.models package<a class="headerlink" href="#genx-models-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="genx.models.lib.html">genx.models.lib package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.ables">genx.models.lib.ables module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.build_ext">genx.models.lib.build_ext module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.edm_slicing">genx.models.lib.edm_slicing module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.elfield">genx.models.lib.elfield module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.instrument">genx.models.lib.instrument module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.int_lay_xmean">genx.models.lib.int_lay_xmean module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.isotropic_matrix">genx.models.lib.isotropic_matrix module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.math_utils">genx.models.lib.math_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.neutron_refl">genx.models.lib.neutron_refl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.offspec2_weave">genx.models.lib.offspec2_weave module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.paratt">genx.models.lib.paratt module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.paratt_weave">genx.models.lib.paratt_weave module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.refl">genx.models.lib.refl module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.scatteringlengths">genx.models.lib.scatteringlengths module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib.xrmr">genx.models.lib.xrmr module</a></li>
<li class="toctree-l2"><a class="reference internal" href="genx.models.lib.html#module-genx.models.lib">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-genx.models.interdiff">
<span id="genx-models-interdiff-module"></span><h2>genx.models.interdiff module<a class="headerlink" href="#module-genx.models.interdiff" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt; Library for specular and off-specular x-ray reflectivity&lt;/h1&gt;
interdiff is a model for specular and off specular simulations including
the effects of interdiffusion in hte calculations. The specular simulations
is conducted with Parrats recursion formula. The off-specular, diffuse
calculations are done with the distorted Born wave approximation (DWBA) as
derived by Holy and with the extensions done by Wormington to include 
diffuse interfaces.
&lt;h2&gt;Classes&lt;/h2&gt;
&lt;h3&gt;Layer&lt;/h3&gt;
&lt;code&gt; Layer(b = 0.0, d = 0.0, f = 0.0+0.0J, dens = 1.0, magn_ang = 0.0, magn = 0.0, sigma = 0.0)&lt;/code&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;d&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The thickness of the layer in AA (Angstroms = 1e-10m)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;f&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The x-ray scattering length per formula unit in electrons. To be strict it is the
number of Thompson scattering lengths for each formula unit.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dens&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The density of formula units in units per Angstroms. Note the units!&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigmai&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The root mean square &lt;em&gt;interdiffusion&lt;/em&gt; of the top interface of the layer in Angstroms.&lt;/dd&gt;               
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigmar&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The root mean square &lt;em&gt;roughness&lt;/em&gt; of the top interface of the layer in Angstroms.&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<p>&lt;h3&gt;Stack&lt;/h3&gt;
&lt;code&gt; Stack(Layers = [], Repetitions = 1)&lt;/code&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Layers&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Layer&lt;/code&gt;s in the stack
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Repetitions&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of repsetions of the stack&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<p>&lt;h3&gt;Sample&lt;/h3&gt;
&lt;code&gt; Sample(Stacks = [], Ambient = Layer(), Substrate = Layer(), eta_z = 10.0,</p>
<blockquote>
<div><p>eta_x = 10.0, h = 1.0)&lt;/code&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Stacks&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Stack&lt;/code&gt;s in the stacks
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ambient&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the Ambient (enviroment above the sample).</p>
<blockquote>
<div>Only the scattering lengths and density of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>&lt;dt&gt;&lt;code&gt;&lt;b&gt;Substrate&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the substrate (enviroment below the sample).</p>
<blockquote>
<div>Only the scattering lengths, density and  roughness of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>&lt;dt&gt;&lt;code&gt;&lt;b&gt;eta_z&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The out-of plane (vertical) correlation length of the roughness
in the sample. Given in AA. &lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;eta_x&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The in-plane global correlation length (it is assumed equal for all layers).
Given in AA.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;h&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The jaggedness parameter, should be between 0 and 1.0. This describes
how jagged the interfaces are. This is also a global parameter for all
interfaces.&lt;/dd&gt;
&lt;/dl&gt;</p>
</div></blockquote>
<p>&lt;h3&gt;Instrument&lt;/h3&gt;
&lt;code&gt;Instrument(wavelength = 1.54, coords = &#8216;tth&#8217;,</p>
<blockquote>
<div><blockquote>
<div>I0 = 1.0 res = 0.001, restype = &#8216;no conv&#8217;, respoints = 5, resintrange = 2,
beamw = 0.01, footype = &#8216;no corr&#8217;, samplelen = 10.0, taylor_n = 1)&lt;/code&gt;</div></blockquote>
<p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;wavelength&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The wavalelngth of the radiation givenin AA (Angstroms)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;coords&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The coordinates of the data given to the SimSpecular function.
The available alternatives are: &#8216;q&#8217; or &#8216;tth&#8217;. Alternatively the numbers
0 (q) or 1 (tth) can be used.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;I0&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The incident intensity (a scaling factor)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ibkg&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The background intensity. Added as a constant value to the calculated
reflectivity&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;res&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resolution of the instrument given in the coordinates of</p>
<blockquote>
<div>&lt;code&gt;coords&lt;/code&gt;. This assumes a gaussian reloution function and</div></blockquote>
<p>&lt;code&gt;res&lt;/code&gt; is the standard deviation of that gaussian.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;restype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Describes the rype of the resolution calculated. One of the alterantives:
&#8216;no conv&#8217;, &#8216;fast conv&#8217;, &#8216;full conv and varying res.&#8217; or &#8216;fast conv + varying res.&#8217;.
The respective numbers 0-3 also works. Note that fast convolution only alllows
a single value into res wheras the other can also take an array with the
same length as the x-data (varying resolution)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;respoints&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of points to include in the resolution calculation. This is only
used for &#8216;full conv and vaying res.&#8217; and &#8216;fast conv + varying res&#8217;&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;resintrange&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Number of standard deviatons to integrate the resolution fucntion times
the relfectivty over&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;footype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Which type of footprint correction is to be applied to the simulation.
One of: &#8216;no corr&#8217;, &#8216;gauss beam&#8217; or &#8216;square beam&#8217;. Alternatively, 
the number 0-2 are also valid. The different choices are self explanatory.
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;beamw&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The width of the beam given in mm. For &#8216;gauss beam&#8217; it should be
the standard deviation. For &#8216;square beam&#8217; it is the full width of the beam.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;samplelen&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The length of the sample given in mm&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;taylor_n&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number terms taken into account in the taylor expansion of 
the fourier integral of the correlation function. More terms more accurate
calculation but also much slower.&lt;/dd&gt;</p>
</div></blockquote>
<dl class="function">
<dt id="genx.models.interdiff.OffSpecularMingInterdiff">
<tt class="descclassname">genx.models.interdiff.</tt><tt class="descname">OffSpecularMingInterdiff</tt><big>(</big><em>TwoThetaQz</em>, <em>ThetaQx</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.interdiff.OffSpecularMingInterdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that simulates the off-specular signal (not implemented)</p>
<p># BEGIN Parameters
TwoThetaQz 1.0
ThetaQx data.x
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.interdiff.SLD_calculations">
<tt class="descclassname">genx.models.interdiff.</tt><tt class="descname">SLD_calculations</tt><big>(</big><em>z</em>, <em>item</em>, <em>sample</em>, <em>inst</em><big>)</big><a class="headerlink" href="#genx.models.interdiff.SLD_calculations" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the scatteringlength density as at the positions z</p>
<p># BEGIN Parameters
z data.x
item &#8220;Re&#8221;
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.interdiff.Specular">
<tt class="descclassname">genx.models.interdiff.</tt><tt class="descname">Specular</tt><big>(</big><em>TwoThetaQz</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.interdiff.Specular" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the specular signal from sample when proped with instrument</p>
<p># BEGIN Parameters
TwoThetaQz data.x
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.interdiff.rand">
<tt class="descclassname">genx.models.interdiff.</tt><tt class="descname">rand</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.interdiff.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Random values in a given shape.</p>
<p>Create an array of the given shape and propagate it with
random samples from a uniform distribution
over <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1)</span></tt>.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt></span></dt>
<dd>Random values.</dd>
</dl>
<p>random</p>
<p>This is a convenience function. If you want an interface that
takes a shape-tuple as the first argument, refer to
np.random.random_sample .</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 0.14022471,  0.96360618],  #random</span>
<span class="go">       [ 0.37601032,  0.25528411],  #random</span>
<span class="go">       [ 0.49313049,  0.94909878]]) #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="genx.models.interdiff.randn">
<tt class="descclassname">genx.models.interdiff.</tt><tt class="descname">randn</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.interdiff.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample (or samples) from the &#8220;standard normal&#8221; distribution.</p>
<p>If positive, int_like or int-convertible arguments are provided,
<cite>randn</cite> generates an array of shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>, filled
with random floats sampled from a univariate &#8220;normal&#8221; (Gaussian)
distribution of mean 0 and variance 1 (if any of the <span class="math">\(d_i\)</span> are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.</p>
<p>This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use <cite>numpy.random.standard_normal</cite> instead.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>Z <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd>A <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</dd>
</dl>
<p>random.standard_normal : Similar, but takes a tuple as its argument.</p>
<p>For random samples from <span class="math">\(N(\mu, \sigma^2)\)</span>, use:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">np.random.randn(...)</span> <span class="pre">+</span> <span class="pre">mu</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-genx.models.mag_refl">
<span id="genx-models-mag-refl-module"></span><h2>genx.models.mag_refl module<a class="headerlink" href="#module-genx.models.mag_refl" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt; Library for specular magnetic x-ray and neutron reflectivity&lt;/h1&gt;
The magnetic reflectivity is calculated according to: S.A. Stephanov and S.K Shina PRB 61 15304. for 
the full anisotropic model. It also one simpler model where the media is considered to be isotropic but 
with different refractive indices for left and right circular light.
The model also has the possibility to calculate the neutron reflectivity from the same sample structure. 
This model includes a interface layer for each &lt;code&gt;Layer&lt;/code&gt;. This means that the model is suitable for 
refining data that looks for interfacial changes of the magnetic moment.</p>
<p>Note! This model should be considered as a gamma version. It is still under heavy development and 
the api can change significantly from version to version. Should only be used by expert users. 
&lt;h2&gt;Classes&lt;/h2&gt;
&lt;h3&gt;Layer&lt;/h3&gt;
&lt;code&gt; Layer(fr = 1e-20j, b = 1e-20j, dd_u = 0.0, d = 0.0, f = 1e-20j, dens = 1.0, resmag = 1.0,</p>
<blockquote>
<div><blockquote>
<div><p>theta_m = 0.0, fm2 = 1e-20j, xs_ai = 0.0, 
sigma_mu = 0.0, fm1 = 1e-20j, dmag_u = 0.0,</p>
<blockquote>
<div><dl class="docutils">
<dt>mag = 0.0, sigma_ml = 0.0, sigma_c = 0.0,</dt>
<dd>resdens = 1.0, phi_m = 0.0, dd_l = 0.0, dmag_l = 0.0)&lt;/code&gt;</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;d&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The thickness of the layer in AA (Angstroms = 1e-10m)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dens&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The density of formula units in units per Angstroms. Note the units!&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigma&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The root mean square roughness of the top interface for the layer in Angstroms.&lt;/dd&gt;        
&lt;dt&gt;&lt;code&gt;&lt;b&gt;f&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The non-resonant x-ray scattering length per formula unit in electrons. To be strict it is the
number of Thompson scattering lengths for each formula unit.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;fr&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resonant x-ray scattering length of the resonant species in electrons. This is multiplied by
&lt;code&gt;resdens*dens&lt;/code&gt; to form the resonant scattering length. The total non-magnetic scattering length is
&lt;code&gt;(f + fr*resdens)*dens&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;fm1&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resonant magnetic part of the scattering length - refers to the magnetic circular dichroic part.
Same units as &lt;code&gt;f&lt;/code&gt;&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;fm2&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resonant magnetic part of the scattering length - refers to the magnetic linear dichroic part.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;b&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The neutron scattering length in fm.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;xs_ai&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The sum of the absorption cross section and the incoherent scattering cross section</p>
<blockquote>
<div>in barns per formula unit for the neutrons&lt;/dd&gt;</div></blockquote>
<p>&lt;dt&gt;&lt;code&gt;&lt;b&gt;mag&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The magnetic moment per formula unit. The magnetic density is &lt;code&gt;mag*dens&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;phi_m&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The in-plane angle of the magnetic moment of the layer relative the projected incident beam for 
x-rays and relative the polarization axis for neutrons.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;theta_m&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The out-of-plane angle of the magnetic moment. &lt;code&gt;theta_m = 0&lt;/code&gt; corresponds to an in-plane 
magnetic moment and &lt;code&gt;theta_m&lt;/code&gt; corresponds to an out-of-plane magnetic moment.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dmag_u&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The relative increase of the magnetic moment in the interface layer. Total magnetic moment is
&lt;code&gt;mag*(1 + dmag_u)&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dmag_l&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;As &lt;code&gt;dmag_u&lt;/code&gt; but for the lower interface layer.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dd_u&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The width of the upper interface layer in Angstroms.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigma_mu&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The roughness of the upper magnetic interface.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigma_ml&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The roughness of the lower magnetic interface.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dd_l&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The width of the lower interface in Angstroms.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;resmag&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The relative amount of magnetic resonant atoms  the total resonant magnetic atoms. The total magnetic scattering
length is calculated 
as (for the circular dichroic term) &lt;code&gt;fm1*resmag*mag*resdens*dens&lt;/code&gt;&lt;/dd&gt;
&lt;/dl&gt;</p>
</div></blockquote>
<p>&lt;h3&gt;Stack&lt;/h3&gt;
&lt;code&gt; Stack(Layers = [], Repetitions = 1)&lt;/code&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Layers&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Layer&lt;/code&gt;s in the stack
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Repetitions&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of repetitions of the stack&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<p>&lt;h3&gt;Sample&lt;/h3&gt;
&lt;code&gt; Sample(Stacks = [], dsld_max = 0.1, dsld_offdiag_max = 0.1,</p>
<blockquote>
<div><blockquote>
<div>compress = &#8216;yes&#8217;, slicing = &#8216;no&#8217;, dsld_n_max = 0.01, 
dabs_n_max = 0.01, sld_buffer = 20.0, sld_delta = 5.0, 
dmag_max = 0.01, sld_mult = 4.0, slice_depth = 1.0, 
Ambient = Amb, Substrate = Sub)&lt;/code&gt;</div></blockquote>
<p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Stacks&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Stack&lt;/code&gt;s in the stacks
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ambient&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the Ambient (enviroment above the sample).</p>
<blockquote>
<div>Only the scattering lengths and density of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>&lt;dt&gt;&lt;code&gt;&lt;b&gt;Substrate&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the substrate (enviroment below the sample).</p>
<blockquote>
<div>Only the scattering lengths, density and  roughness of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>dt&gt;&lt;code&gt;&lt;b&gt;dsld_max&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The maximum allowed step in the scattering length density for x-rays (diagonal terms)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dsld_offdiag_max&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The maximum allowed step in the scattering length density for the offdiagonal terms of the 
scattering length (magnetic part)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;compress&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A flag that signals if the sliced composition profile should be compressed.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;slicing&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A flag that signals if the composition profile should be sliced up.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dsld_n_max&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The maximum allowed step (in compression) for the neutron scattering length.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dabs_n_max&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The maximum allowed step (in compression) for the neutron absorption (in units of barn/AA^3)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sld_buffer&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A buffer for the slicing calculations (to assure convergence in the sld profile. &lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sld_delta&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;An extra buffer - needed at all?&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dmag_max&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The maximum allowed step (in compression) for the magnetization. Primarily intended to limit the 
steps in the magnetic profile for neutrons.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sld_mult&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A multiplication factor for a buffer that takes the roughness into account.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;slice_depth&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The depth of the slices in the calculation of the sliced scattering length density profile.&lt;/dd&gt;
&lt;/dl&gt;</p>
</div></blockquote>
<p>&lt;h3&gt;Instrument&lt;/h3&gt;
&lt;code&gt;model.Instrument(res = 0.001,theory = &#8216;neutron spin-pol&#8217;,</p>
<blockquote>
<div><blockquote>
<div>footype = &#8216;no corr&#8217;,beamw = 0.01,
wavelength = 4.4,respoints = 5,xpol = &#8216;circ+&#8217;,Ibkg = 0.0,
I0 = 1.0,samplelen = 10.0,npol = &#8216;++&#8217;,restype = &#8216;no conv&#8217;,
coords = &#8216;tth&#8217;,resintrange = 2)&lt;/code&gt;</div></blockquote>
<p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;wavelength&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The wavalelngth of the radiation givenin AA (Angstroms)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;coords&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The coordinates of the data given to the SimSpecular function.
The available alternatives are: &#8216;q&#8217; or &#8216;tth&#8217;. Alternatively the numbers
0 (q) or 1 (tth) can be used.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;I0&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The incident intensity (a scaling factor)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ibkg&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The background intensity. Added as a constant value to the calculated
reflectivity&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;res&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resolution of the instrument given in the coordinates of</p>
<blockquote>
<div>&lt;code&gt;coords&lt;/code&gt;. This assumes a gaussian reloution function and</div></blockquote>
<p>&lt;code&gt;res&lt;/code&gt; is the standard deviation of that gaussian.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;restype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Describes the rype of the resolution calculated. One of the alterantives:
&#8216;no conv&#8217;, &#8216;fast conv&#8217;, &#8216;full conv and varying res.&#8217; or &#8216;fast conv + varying res.&#8217;.
The respective numbers 0-3 also works. Note that fast convolution only alllows
a single value into res wheras the other can also take an array with the
same length as the x-data (varying resolution)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;respoints&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of points to include in the resolution calculation. This is only
used for &#8216;full conv and vaying res.&#8217; and &#8216;fast conv + varying res&#8217;&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;resintrange&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Number of standard deviatons to integrate the resolution fucntion times
the relfectivty over&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;footype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Which type of footprint correction is to be applied to the simulation.
One of: &#8216;no corr&#8217;, &#8216;gauss beam&#8217; or &#8216;square beam&#8217;. Alternatively, 
the number 0-2 are also valid. The different choices are self explanatory.
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;beamw&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The width of the beam given in mm. For &#8216;gauss beam&#8217; it should be
the standard deviation. For &#8216;square beam&#8217; it is the full width of the beam.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;samplelen&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The length of the sample given in mm&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;theory&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Defines which theory (code) that should calcualte the reflectivity. Should be one of: 
&#8216;x-ray anis.&#8217;, &#8216;x-ray simpl. anis.&#8217;, &#8216;neutron spin-pol&#8217; or &#8216;neutron spin-flip&#8217;.
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;xpol&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The polarization state of the x-ray beam. Should be one of: &#8216;circ+&#8217;,&#8217;circ-&#8216;,&#8217;tot&#8217;, &#8216;ass&#8217;, &#8216;sigma&#8217; or &#8216;pi&#8217;&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;npol&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The neutron polarization state. Should be &#8216;++&#8217;,&#8217;uu&#8217;, &#8216;&#8211;&#8217;, &#8216;dd&#8217; alt. &#8216;+-&#8216;,&#8217;ud&#8217; for spin flip.&lt;/dd&gt;</p>
</div></blockquote>
<dl class="data">
<dt id="genx.models.mag_refl.AA_to_eV">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">AA_to_eV</tt><em class="property"> = 12398.5</em><a class="headerlink" href="#genx.models.mag_refl.AA_to_eV" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from Angstrom to eV E = AA_to_eV/lamda.</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.EnergySpecular">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">EnergySpecular</tt><big>(</big><em>Energy</em>, <em>TwoThetaQz</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.EnergySpecular" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the specular signal from sample when probed with instrument. Energy should be in eV.</p>
<p># BEGIN Parameters
Energy data.x
TwoThetaQz 3.0
# END Parameters</p>
</dd></dl>

<dl class="class">
<dt id="genx.models.mag_refl.NBuffer">
<em class="property">class </em><tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">NBuffer</tt><a class="headerlink" href="#genx.models.mag_refl.NBuffer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.Rdd">
<tt class="descname">Rdd</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.Rdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.Rdu">
<tt class="descname">Rdu</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.Rdu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.Rud">
<tt class="descname">Rud</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.Rud" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.Ruu">
<tt class="descname">Ruu</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.Ruu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.TwoThetaQz">
<tt class="descname">TwoThetaQz</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.TwoThetaQz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.NBuffer.parameters">
<tt class="descname">parameters</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.NBuffer.parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.OffSpecular">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">OffSpecular</tt><big>(</big><em>TwoThetaQz</em>, <em>ThetaQx</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.OffSpecular" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that simulates the off-specular signal (not implemented)</p>
<p># BEGIN Parameters
TwoThetaQz 1.0
ThetaQx data.x
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.SLD_calculations">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">SLD_calculations</tt><big>(</big><em>z</em>, <em>item</em>, <em>sample</em>, <em>inst</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.SLD_calculations" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the scatteringlength density as at the positions z
if item is None or &#8220;all&#8221; the function returns a dictonary of values.
Otherwise it returns the item as identified by its string.</p>
<p># BEGIN Parameters
z data.x
item &#8220;Re sld_c&#8221;
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.Specular">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">Specular</tt><big>(</big><em>TwoThetaQz</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.Specular" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the specular signal from sample when proped with instrument</p>
<p># BEGIN Parameters
TwoThetaQz data.x
# END Parameters</p>
</dd></dl>

<dl class="class">
<dt id="genx.models.mag_refl.XBuffer">
<em class="property">class </em><tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">XBuffer</tt><a class="headerlink" href="#genx.models.mag_refl.XBuffer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="genx.models.mag_refl.XBuffer.W">
<tt class="descname">W</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.XBuffer.W" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.XBuffer.coords">
<tt class="descname">coords</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.XBuffer.coords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.XBuffer.g_0">
<tt class="descname">g_0</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.XBuffer.g_0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.XBuffer.parameters">
<tt class="descname">parameters</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.XBuffer.parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.mag_refl.XBuffer.wavelength">
<tt class="descname">wavelength</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.mag_refl.XBuffer.wavelength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.analytical_reflectivity">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">analytical_reflectivity</tt><big>(</big><em>sample</em>, <em>instrument</em>, <em>theta</em>, <em>TwoThetaQz</em>, <em>xray_energy</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.analytical_reflectivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.compose_sld">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">compose_sld</tt><big>(</big><em>sample</em>, <em>instrument</em>, <em>theta</em>, <em>xray_energy</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.compose_sld" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.compose_sld_anal">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">compose_sld_anal</tt><big>(</big><em>z</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.compose_sld_anal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose a analytical profile funciton</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.convolute_reflectivity">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">convolute_reflectivity</tt><big>(</big><em>R</em>, <em>instrument</em>, <em>foocor</em>, <em>TwoThetaQz</em>, <em>weight</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.convolute_reflectivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.correct_reflectivity">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">correct_reflectivity</tt><big>(</big><em>R</em>, <em>TwoThetaQz</em>, <em>instrument</em>, <em>theta</em>, <em>weight</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.correct_reflectivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.extract_anal_iso_pars">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">extract_anal_iso_pars</tt><big>(</big><em>sample</em>, <em>instrument</em>, <em>theta</em>, <em>xray_energy</em>, <em>pol='+'</em>, <em>Q=None</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.extract_anal_iso_pars" title="Permalink to this definition">¶</a></dt>
<dd><p>Note Q is only used for Neutron TOF
:param lamda:</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.footprint_correction">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">footprint_correction</tt><big>(</big><em>instrument</em>, <em>theta</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.footprint_correction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.rand">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">rand</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Random values in a given shape.</p>
<p>Create an array of the given shape and propagate it with
random samples from a uniform distribution
over <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1)</span></tt>.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt></span></dt>
<dd>Random values.</dd>
</dl>
<p>random</p>
<p>This is a convenience function. If you want an interface that
takes a shape-tuple as the first argument, refer to
np.random.random_sample .</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 0.14022471,  0.96360618],  #random</span>
<span class="go">       [ 0.37601032,  0.25528411],  #random</span>
<span class="go">       [ 0.49313049,  0.94909878]]) #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.randn">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">randn</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample (or samples) from the &#8220;standard normal&#8221; distribution.</p>
<p>If positive, int_like or int-convertible arguments are provided,
<cite>randn</cite> generates an array of shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>, filled
with random floats sampled from a univariate &#8220;normal&#8221; (Gaussian)
distribution of mean 0 and variance 1 (if any of the <span class="math">\(d_i\)</span> are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.</p>
<p>This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use <cite>numpy.random.standard_normal</cite> instead.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>Z <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd>A <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</dd>
</dl>
<p>random.standard_normal : Similar, but takes a tuple as its argument.</p>
<p>For random samples from <span class="math">\(N(\mu, \sigma^2)\)</span>, use:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">np.random.randn(...)</span> <span class="pre">+</span> <span class="pre">mu</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.reflectivity_xmag">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">reflectivity_xmag</tt><big>(</big><em>sample</em>, <em>instrument</em>, <em>theta</em>, <em>TwoThetaQz</em>, <em>xray_energy</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.reflectivity_xmag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.mag_refl.slicing_reflectivity">
<tt class="descclassname">genx.models.mag_refl.</tt><tt class="descname">slicing_reflectivity</tt><big>(</big><em>sample</em>, <em>instrument</em>, <em>theta</em>, <em>TwoThetaQz</em>, <em>xray_energy</em><big>)</big><a class="headerlink" href="#genx.models.mag_refl.slicing_reflectivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-genx.models.spec_nx">
<span id="genx-models-spec-nx-module"></span><h2>genx.models.spec_nx module<a class="headerlink" href="#module-genx.models.spec_nx" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt;Library for combined x-ray and neutrons simulations.&lt;/h1&gt;
&lt;p&gt;The neutron simulations is capable of handling non-magnetic, 
magnetic non-spin flip as well as neutron spin-flip reflectivity. &lt;/p&gt;
&lt;h2&gt;Classes&lt;/h2&gt;
&lt;h3&gt;Layer&lt;/h3&gt;
&lt;code&gt; Layer(b = 0.0, d = 0.0, f = 0.0+0.0J, dens = 1.0, magn_ang = 0.0, magn = 0.0, sigma = 0.0)&lt;/code&gt;</p>
<blockquote>
<div><p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;b&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The neutron scattering length per formula unit in fm (fermi meter = 1e-15m)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;d&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The thickness of the layer in AA (Angstroms = 1e-10m)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;f&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The x-ray scattering length per formula unit in electrons. To be strict it is the
number of Thompson scattering lengths for each formula unit.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;dens&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The density of formula units in units per Angstroms. Note the units!&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;magn_ang&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The angle of the magnetic moment in degress. 0 degrees correspond to
a moment collinear with the neutron spin.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;magn&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The magnetic moment per formula unit (same formula unit as b and dens refer to)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;sigma&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The root mean square roughness of the top interface of the layer in Angstroms.&lt;/dd&gt;     
&lt;dt&gt;&lt;code&gt;&lt;b&gt;xs_ai&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The sum of the absorption cross section and the incoherent scattering cross section</p>
<blockquote>
<div>in barns for neutrons&lt;/dd&gt;</div></blockquote>
<p>&lt;/dl&gt;</p>
</div></blockquote>
<p>&lt;h3&gt;Stack&lt;/h3&gt;
&lt;code&gt; Stack(Layers = [], Repetitions = 1)&lt;/code&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Layers&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Layer&lt;/code&gt;s in the stack
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Repetitions&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of repsetions of the stack&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<p>&lt;h3&gt;Sample&lt;/h3&gt;
&lt;code&gt; Sample(Stacks = [], Ambient = Layer(), Substrate = Layer())&lt;/code&gt;</p>
<blockquote>
<div><p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Stacks&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;list&lt;/code&gt; consiting of &lt;code&gt;Stack&lt;/code&gt;s in the stacks
the first item is the layer closest to the bottom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ambient&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the Ambient (enviroment above the sample).</p>
<blockquote>
<div>Only the scattering lengths and density of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>&lt;dt&gt;&lt;code&gt;&lt;b&gt;Substrate&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A &lt;code&gt;Layer&lt;/code&gt; describing the substrate (enviroment below the sample).</p>
<blockquote>
<div>Only the scattering lengths, density and  roughness of the layer is used.&lt;/dd&gt;</div></blockquote>
<p>&lt;/dl&gt;</p>
</div></blockquote>
<p>&lt;h3&gt;Instrument&lt;/h3&gt;
&lt;code&gt;Instrument(probe = &#8216;x-ray&#8217;, wavelength = 1.54, coords = &#8216;tth&#8217;,</p>
<blockquote>
<div><blockquote>
<div>I0 = 1.0 res = 0.001, restype = &#8216;no conv&#8217;, respoints = 5, resintrange = 2,
beamw = 0.01, footype = &#8216;no corr&#8217;, samplelen = 10.0, incangle = 0.0, pol = &#8216;uu&#8217;)&lt;/code&gt;</div></blockquote>
<p>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;probe&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Describes the radiation and measurments used is one of:
&#8216;x-ray&#8217;, &#8216;neutron&#8217;, &#8216;neutron pol&#8217;, &#8216;neutron pol spin flip&#8217;, &#8216;neutron tof&#8217;, &#8216;neutron pol tof&#8217; 
or the respective
number 0, 1, 2, 3, 4, 5, 6. The calculations for x-rays uses &lt;code&gt;f&lt;/code&gt; for the scattering
length for neutrons &lt;code&gt;b&lt;/code&gt; for &#8216;neutron pol&#8217;, &#8216;neutron pol spin flip&#8217; and 
&#8216;neutron pol tof&#8217; alternatives the &lt;code&gt;magn&lt;/code&gt;
is used in the calculations. Note that the angle of magnetization &lt;code&gt;magn_ang&lt;/code&gt;
is only used in the last alternative.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;wavelength&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The wavalelngth of the radiation givenin AA (Angstroms)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;coords&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The coordinates of the data given to the SimSpecular function.
The available alternatives are: &#8216;q&#8217; or &#8216;tth&#8217;. Alternatively the numbers
0 (q) or 1 (tth) can be used.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;I0&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The incident intensity (a scaling factor)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;Ibkg&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The background intensity. Added as a constant value to the calculated
reflectivity&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;res&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The resolution of the instrument given in the coordinates of</p>
<blockquote>
<div>&lt;code&gt;coords&lt;/code&gt;. This assumes a gaussian reloution function and</div></blockquote>
<p>&lt;code&gt;res&lt;/code&gt; is the standard deviation of that gaussian.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;restype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Describes the rype of the resolution calculated. One of the alterantives:
&#8216;no conv&#8217;, &#8216;fast conv&#8217;, &#8216;full conv and varying res.&#8217; or &#8216;fast conv + varying res.&#8217;.
The respective numbers 0-3 also works. Note that fast convolution only alllows
a single value into res wheras the other can also take an array with the
same length as the x-data (varying resolution)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;respoints&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The number of points to include in the resolution calculation. This is only
used for &#8216;full conv and vaying res.&#8217; and &#8216;fast conv + varying res&#8217;&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;resintrange&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Number of standard deviatons to integrate the resolution fucntion times
the relfectivty over&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;footype&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Which type of footprint correction is to be applied to the simulation.
One of: &#8216;no corr&#8217;, &#8216;gauss beam&#8217; or &#8216;square beam&#8217;. Alternatively, 
the number 0-2 are also valid. The different choices are self expnalatory.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;beamw&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The width of the beam given in mm. For &#8216;gauss beam&#8217; it should be
the standard deviation. For &#8216;square beam&#8217; it is the full width of the beam.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;samplelen&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The length of the sample given in mm&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;incangle&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The incident angle of the neutrons, only valid in tof mode&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;pol&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The measured polarization of the instrument. Valid options are:
&#8216;uu&#8217;,&#8217;dd&#8217; or &#8216;ud&#8217;, or the respective number 0-2 also works.&lt;/dd&gt;</p>
</div></blockquote>
<dl class="data">
<dt id="genx.models.spec_nx.AA_to_eV">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">AA_to_eV</tt><em class="property"> = 12398.5</em><a class="headerlink" href="#genx.models.spec_nx.AA_to_eV" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion from Angstrom to eV E = AA_to_eV/lamda.</p>
</dd></dl>

<dl class="class">
<dt id="genx.models.spec_nx.Buffer">
<em class="property">class </em><tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">Buffer</tt><a class="headerlink" href="#genx.models.spec_nx.Buffer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="genx.models.spec_nx.Buffer.Rdd">
<tt class="descname">Rdd</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.spec_nx.Buffer.Rdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.spec_nx.Buffer.Rdu">
<tt class="descname">Rdu</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.spec_nx.Buffer.Rdu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.spec_nx.Buffer.Rud">
<tt class="descname">Rud</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.spec_nx.Buffer.Rud" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.spec_nx.Buffer.Ruu">
<tt class="descname">Ruu</tt><em class="property"> = 0</em><a class="headerlink" href="#genx.models.spec_nx.Buffer.Ruu" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="genx.models.spec_nx.Buffer.parameters">
<tt class="descname">parameters</tt><em class="property"> = None</em><a class="headerlink" href="#genx.models.spec_nx.Buffer.parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.EnergySpecular">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">EnergySpecular</tt><big>(</big><em>Energy</em>, <em>TwoThetaQz</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.EnergySpecular" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the specular signal from sample when probed with instrument. Energy should be in eV.</p>
<p># BEGIN Parameters
Energy data.x
TwoThetaQz 3.0
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.OffSpecular">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">OffSpecular</tt><big>(</big><em>TwoThetaQz</em>, <em>ThetaQx</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.OffSpecular" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that simulates the off-specular signal (not implemented)</p>
<p># BEGIN Parameters
TwoThetaQz 1.0
ThetaQx data.x
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.SLD_calculations">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">SLD_calculations</tt><big>(</big><em>z</em>, <em>item</em>, <em>sample</em>, <em>inst</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.SLD_calculations" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the scatteringlength density as at the positions z
if item is None or &#8220;all&#8221; the function returns a dictonary of values.
Otherwise it returns the item as identified by its string.</p>
<p># BEGIN Parameters
z data.x
item &#8216;Re&#8217;
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.Specular">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">Specular</tt><big>(</big><em>TwoThetaQz</em>, <em>sample</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.Specular" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the specular signal from sample when probed with instrument</p>
<p># BEGIN Parameters
TwoThetaQz data.x
# END Parameters</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.footprintcorr">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">footprintcorr</tt><big>(</big><em>Q</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.footprintcorr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.rand">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">rand</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Random values in a given shape.</p>
<p>Create an array of the given shape and propagate it with
random samples from a uniform distribution
over <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1)</span></tt>.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should all be positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt></span></dt>
<dd>Random values.</dd>
</dl>
<p>random</p>
<p>This is a convenience function. If you want an interface that
takes a shape-tuple as the first argument, refer to
np.random.random_sample .</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[ 0.14022471,  0.96360618],  #random</span>
<span class="go">       [ 0.37601032,  0.25528411],  #random</span>
<span class="go">       [ 0.49313049,  0.94909878]]) #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.randn">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">randn</tt><big>(</big><em>d0</em>, <em>d1</em>, <em>...</em>, <em>dn</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.randn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample (or samples) from the &#8220;standard normal&#8221; distribution.</p>
<p>If positive, int_like or int-convertible arguments are provided,
<cite>randn</cite> generates an array of shape <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>, filled
with random floats sampled from a univariate &#8220;normal&#8221; (Gaussian)
distribution of mean 0 and variance 1 (if any of the <span class="math">\(d_i\)</span> are
floats, they are first converted to integers by truncation). A single
float randomly sampled from the distribution is returned if no
argument is provided.</p>
<p>This is a convenience function.  If you want an interface that takes a
tuple as the first argument, use <cite>numpy.random.standard_normal</cite> instead.</p>
<dl class="docutils">
<dt>d0, d1, ..., dn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd>The dimensions of the returned array, should be all positive.
If no argument is given a single Python float is returned.</dd>
</dl>
<dl class="docutils">
<dt>Z <span class="classifier-delimiter">:</span> <span class="classifier">ndarray or float</span></dt>
<dd>A <tt class="docutils literal"><span class="pre">(d0,</span> <span class="pre">d1,</span> <span class="pre">...,</span> <span class="pre">dn)</span></tt>-shaped array of floating-point samples from
the standard normal distribution, or a single such float if
no parameters were supplied.</dd>
</dl>
<p>random.standard_normal : Similar, but takes a tuple as its argument.</p>
<p>For random samples from <span class="math">\(N(\mu, \sigma^2)\)</span>, use:</p>
<p><tt class="docutils literal"><span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">np.random.randn(...)</span> <span class="pre">+</span> <span class="pre">mu</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
<span class="go">2.1923875335537315 #random</span>
</pre></div>
</div>
<p>Two-by-four array of samples from N(3, 6.25):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
<span class="go">array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random</span>
<span class="go">       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.resolution_init">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">resolution_init</tt><big>(</big><em>TwoThetaQz</em>, <em>instrument</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.resolution_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Inits the dependet variable with regards to coordinates and resolution.</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.spec_nx.resolutioncorr">
<tt class="descclassname">genx.models.spec_nx.</tt><tt class="descname">resolutioncorr</tt><big>(</big><em>R</em>, <em>TwoThetaQz</em>, <em>foocor</em>, <em>instrument</em>, <em>weight</em><big>)</big><a class="headerlink" href="#genx.models.spec_nx.resolutioncorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Do the convolution of the reflectivity to account for resolution effects.</p>
</dd></dl>

</div>
<div class="section" id="module-genx.models.sxrd">
<span id="genx-models-sxrd-module"></span><h2>genx.models.sxrd module<a class="headerlink" href="#module-genx.models.sxrd" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt;Library for surface x-ray diffraction simulations&lt;/h1&gt;
&lt;p&gt; The problem of modelling the sample is divided to four
different classes: Sample, Slab, UnitCell and Instrument.
A Slab is the basic unit that builds up a sample and can
be seen as a quasi-unitcell for the sxrd problem.
Stricitly it is a 2D unitcell with a finite extension
out-of-plane. The Sample is then built from these Slabs one slab for
the bulk and a list of slabs for the surface strucutre.</p>
<p>&lt;p&gt; The unitcell consists of parameters for  the unitcell and the
instrument contains instrument variables. See below for a full list.</p>
<p>&lt;h2&gt;Classes&lt;/h2&gt;
&lt;h3&gt;Slab&lt;/h3&gt;
&lt;code&gt; Slab(c = 1.0, slab_oc = 1.0)&lt;/code&gt;&lt;br&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;c&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; A scale factor for ou-of-plane extension of the
Slab. All z-positions will be scaled with this factor.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;slab_oc&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; A global scaling of the occupancy of all atoms in the
slab.&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<dl class="docutils">
<dt>&lt;code&gt; [Slab].add_atom(id, el, x, y, z, u = 0, oc = 1.0, m = 1.0)&lt;/code&gt;&lt;br&gt;</dt>
<dd>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;id&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A unique string identifier &lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;el&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The element described in a string. Note that
ions is denoted as &#8220;Sr2p&#8221; and &#8220;O2m&#8221; where 2 is the oxidation number and
p and m denoted plus and minus charge.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;x&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The x-position in Slab unit cell coords (same as given by the
UnitCell)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;y&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The y-position in Slab unit cell coords (same as given by the
UnitCell)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;z&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The z-position in Slab unit cell coords (The Unitcell c scaled by
a factor of the c-value for the slab)&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;u&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The mean-square displacement for the atom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;oc&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The occupancy of the atom&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;m&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; The multiplicity of the site, defined as in the international tables
of crystallogrphy. Note that it is plane goups and NOT space groups that
will produce valid results.&lt;/dd&gt;
&lt;/dl&gt;</dd>
<dt>&lt;code&gt; [Slab].copy()&lt;/code&gt;&lt;br&gt;</dt>
<dd>Creates a copy of object [Slab]. This decouples the new object
returned by copy from the original [Slab].</dd>
<dt>&lt;code&gt; [Slab].find_atoms(expression)&lt;/code&gt;&lt;br&gt;</dt>
<dd>Function to locate atoms in a slab in order to connect parameters
between them. Returns an AtomGroup. 
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;expression&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; Either a list of the same length as the number of atoms or
a string that will evaluate to true or false for each atom.
Allowed variables are: &lt;code&gt;x, y, z, id, el, u, ov, m,/code&gt;&lt;/dd&gt;
&lt;/dl&gt;</dd>
<dt>&lt;code&gt; [Slab].all_atoms()&lt;/code&gt;&lt;br&gt;</dt>
<dd>Yields all atoms inside a slab as an AtomGroup.
Returns an AtomGroup.</dd>
<dt>&lt;code&gt; [Slab][id]&lt;/code&gt;&lt;br&gt;</dt>
<dd>Locates atom that has id &lt;code&gt;id&lt;/code&gt;. Returns an AtomGroup
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;id&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Uniqe string identifer for one atom &lt;/dd&gt;
&lt;/dl&gt;</dd>
</dl>
<p>&lt;h3&gt;Sample&lt;/h3&gt;
&lt;code&gt; Sample(inst, bulk_slab, slabs, unit_cell, surface_sym = [],
bulk_sym = []) &lt;/code&gt;&lt;br&gt;</p>
<blockquote>
<div>&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;inst&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt; Instrument object for the sample
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;bulk_slab&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;The Slab that describes the bulk strucutre
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;slabs&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A list ([]) of slabs for the surface structure
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;unit_cell&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A UnitCell object 
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;surface_sym&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A list ([]) of SymTrans objects describing the surface symmetry.
Default value - an empty list will implement a p1 symmetry, that is no
symmetry operations at all.
&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;bulk_sym&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;A list ([]) of SymTrans objects describing the bulk symmetry.
Default value - an empty list will implement a p1 symmetry, that is
no symetry operations at all.
&lt;/dd&gt;
&lt;/dl&gt;</div></blockquote>
<p>&lt;code&gt;[Sample].calc_f(h, k, l)&lt;/code&gt;&lt;br&gt;
Calculates the total structure factor (complex number) from the
the surface and bulk strucutre. Returns an array of the same size
as h, k, l. (h, k, l should be of the same legth and is given in
coordinates of the reciprocal lattice as defnined by the uit_cell coords)
&lt;code&gt;[Sample].turbo_calc_f(h, k, l)&lt;/code&gt;&lt;br&gt;
A faster version of &lt;code&gt;calc_f&lt;/code&gt; which uses inline c code to increase
the speed. Can be more unstable than &lt;code&gt;calc_f&lt;/code&gt; use on your own risk.
&lt;code&gt;[Sample].calc_rhos(x, y, z, sb)&lt;/code&gt;&lt;br&gt;
Calculate the the surface electron density of a model. The parameter sb is a Gaussian convolution factor given the width of the Gaussian in reciprocal space.
Used mainly for comparison with direct methods, i.e. DCAF.
NOTE that the transformation from the width of the window function given
in &lt;code&gt;dimes.py&lt;/code&gt; is &lt;code&gt;sqrt(2)*pi*[]&lt;/code&gt;</p>
<dl class="class">
<dt id="genx.models.sxrd.AtomGroup">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">AtomGroup</tt><big>(</big><em>slab=None</em>, <em>id=None</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.AtomGroup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="genx.models.sxrd.AtomGroup.add_atom">
<tt class="descname">add_atom</tt><big>(</big><em>slab</em>, <em>id</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.AtomGroup.add_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an atom to the group.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.AtomGroup.comp_coupl">
<tt class="descname">comp_coupl</tt><big>(</big><em>other</em>, <em>self_copy=False</em>, <em>exclusive=True</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.AtomGroup.comp_coupl" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to create set-get methods to use compositions
in the atomic groups. Note that this does not affect
the slabs global occupancy. If self_copy is True the
returned value will be a copy of self.
If exculive is true reomves all methods from the
previous AtomGroups that are coupled.</p>
</dd></dl>

<dl class="attribute">
<dt id="genx.models.sxrd.AtomGroup.par_names">
<tt class="descname">par_names</tt><em class="property"> = ['dx', 'dy', 'dz', 'u', 'oc']</em><a class="headerlink" href="#genx.models.sxrd.AtomGroup.par_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.AtomGroup.update_setget_funcs">
<tt class="descname">update_setget_funcs</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.AtomGroup.update_setget_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Update all the atomic set and get functions</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd.Instrument">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">Instrument</tt><big>(</big><em>wavel</em>, <em>alpha</em>, <em>geom='alpha_in fixed'</em>, <em>flib=&lt;genx.models.lib.scatteringlengths.FormFactor object at 0x110f0ec90&gt;</em>, <em>rholib=&lt;genx.models.lib.scatteringlengths.FormFactor object at 0x110f0ed10&gt;</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that keeps tracks of instrument settings.</p>
<dl class="attribute">
<dt id="genx.models.sxrd.Instrument.geometries">
<tt class="descname">geometries</tt><em class="property"> = ['alpha_in fixed', 'alpha_in eq alpha_out', 'alpha_out fixed']</em><a class="headerlink" href="#genx.models.sxrd.Instrument.geometries" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.get_alpha">
<tt class="descname">get_alpha</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.get_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the freexed angle. See set_alpha.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.get_energy">
<tt class="descname">get_energy</tt><big>(</big><em>energy</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the photon energy in keV</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.get_inten">
<tt class="descname">get_inten</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.get_inten" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieves the intensity</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.get_wavel">
<tt class="descname">get_wavel</tt><big>(</big><em>wavel</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.get_wavel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the wavelength in AA</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_alpha">
<tt class="descname">set_alpha</tt><big>(</big><em>alpha</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the freezed angle. The meaning of this angle varies depening
of the geometry parameter.</p>
<p>geo =  &#8220;alpha_in fixed&#8221;, alpha = alpha_in
geo = &#8220;alpha_in eq alpha_out&#8221;, alpha = alpha_in = alpha_out
geo = &#8220;alpha_out fixed&#8221;, alpha = alpha_out</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_energy">
<tt class="descname">set_energy</tt><big>(</big><em>energy</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the energy in keV</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_flib">
<tt class="descname">set_flib</tt><big>(</big><em>flib</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_flib" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the structure factor library</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_geometry">
<tt class="descname">set_geometry</tt><big>(</big><em>geom</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the measurement geometry</p>
<p>Should be one of the items in Instrument.geometry</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_inten">
<tt class="descname">set_inten</tt><big>(</big><em>inten</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_inten" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the incomming intensity</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_rholib">
<tt class="descname">set_rholib</tt><big>(</big><em>rholib</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_rholib" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the rho library (electron density shape of the atoms)</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Instrument.set_wavel">
<tt class="descname">set_wavel</tt><big>(</big><em>wavel</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Instrument.set_wavel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the wavelength in AA</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd.Sample">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">Sample</tt><big>(</big><em>inst</em>, <em>bulk_slab</em>, <em>slabs</em>, <em>unit_cell</em>, <em>surface_sym=</em>, <span class="optional">[</span><span class="optional">]</span><em>bulk_sym=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="genx.models.sxrd.Sample.calc_f">
<tt class="descname">calc_f</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.calc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors for the sample</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.calc_fb">
<tt class="descname">calc_fb</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.calc_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors from the bulk</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.calc_fs">
<tt class="descname">calc_fs</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.calc_fs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors from the surface</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.calc_rhos">
<tt class="descname">calc_rhos</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>sb=0.8</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.calc_rhos" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcualte the electron density of the unitcell</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.create_uc_output">
<tt class="descname">create_uc_output</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.create_uc_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Create atomic positions and such for output</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.set_bulk_slab">
<tt class="descname">set_bulk_slab</tt><big>(</big><em>bulk_slab</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.set_bulk_slab" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the bulk unit cell to bulk_slab</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.set_bulk_sym">
<tt class="descname">set_bulk_sym</tt><big>(</big><em>sym_list</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.set_bulk_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the list of allowed symmetry operations for the bulk</p>
<p>sym_list has to be a list ([]) of symmetry elements from the
class SymTrans</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.set_slabs">
<tt class="descname">set_slabs</tt><big>(</big><em>slabs</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.set_slabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the slabs of the sample.</p>
<p>slabs should be a list of objects from the class Slab</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.set_surface_sym">
<tt class="descname">set_surface_sym</tt><big>(</big><em>sym_list</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.set_surface_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the list of symmetry operations for the surface.</p>
<p>sym_list has to be a list ([]) of symmetry elements from the
class SymTrans</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.set_unit_cell">
<tt class="descname">set_unit_cell</tt><big>(</big><em>unit_cell</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.set_unit_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the unitcell of the sample</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.turbo_calc_f">
<tt class="descname">turbo_calc_f</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.turbo_calc_f" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors for the sample with
inline c code for the surface.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Sample.turbo_calc_fs">
<tt class="descname">turbo_calc_fs</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Sample.turbo_calc_fs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors with weave (inline c code)
Produces faster simulations of large structures.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd.Slab">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">Slab</tt><big>(</big><em>name=''</em>, <em>c=1.0</em>, <em>slab_oc=1.0</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="genx.models.sxrd.Slab.add_atom">
<tt class="descname">add_atom</tt><big>(</big><em>id</em>, <em>element</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>u=0.0</em>, <em>oc=1.0</em>, <em>m=1.0</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.add_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an atom to the slab.</p>
<p>id - a unique id for this atom (string)
element - the element of this atom has to be found
within the scatteringlength table.
x, y, z - position in the assymetricv unit cell (floats)
u - debye-waller parameter for the atom
oc - occupancy of the atomic site</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.all_atoms">
<tt class="descname">all_atoms</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.all_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts all atoms in the slab to an AtomGroup.</p>
<p>returns: AtomGroup</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.del_atom">
<tt class="descname">del_atom</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.del_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove atom identified with id</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.find_atoms">
<tt class="descname">find_atoms</tt><big>(</big><em>expression</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.find_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the atoms that satisfy the logical expression given in the
string expression. Expression can also be a list or array of the
same length as the number of atoms in the slab.</p>
<p>Allowed variables in expression are:
x, y, z, u, occ, id, el
returns an AtomGroup</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.get_c">
<tt class="descname">get_c</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.get_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the out-of-plane extension of the slab in UC coord.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.get_oc">
<tt class="descname">get_oc</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.get_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the global occupancy of the slab</p>
</dd></dl>

<dl class="attribute">
<dt id="genx.models.sxrd.Slab.par_names">
<tt class="descname">par_names</tt><em class="property"> = ['dx', 'dy', 'dz', 'u', 'oc', 'm']</em><a class="headerlink" href="#genx.models.sxrd.Slab.par_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.set_c">
<tt class="descname">set_c</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.set_c" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the out-of-plane extension of the slab.
Note that this is in the defined UC coords given in
the corresponding sample</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.Slab.set_oc">
<tt class="descname">set_oc</tt><big>(</big><em>oc</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.Slab.set_oc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a global occupation parameter for the entire slab.
should be between 0 and 1. To create the real occupancy this
value is multiplied with the occupancy for that atom.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd.SymTrans">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">SymTrans</tt><big>(</big><em>P=[[1, 0], [0, 1]], t=[0, 0]</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.SymTrans" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="genx.models.sxrd.SymTrans.apply_symmetry">
<tt class="descname">apply_symmetry</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.SymTrans.apply_symmetry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.SymTrans.trans_x">
<tt class="descname">trans_x</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.SymTrans.trans_x" title="Permalink to this definition">¶</a></dt>
<dd><p>transformed x coord</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.SymTrans.trans_y">
<tt class="descname">trans_y</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.SymTrans.trans_y" title="Permalink to this definition">¶</a></dt>
<dd><p>transformed x coord</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd.UnitCell">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">UnitCell</tt><big>(</big><em>a</em>, <em>b</em>, <em>c</em>, <em>alpha=90</em>, <em>beta=90</em>, <em>gamma=90</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Class containing the  unitcell.
This also allows for simple crystalloraphic computing of different
properties.</p>
<dl class="method">
<dt id="genx.models.sxrd.UnitCell.abs_hkl">
<tt class="descname">abs_hkl</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.abs_hkl" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute value of (h,k,l) vector in units of
AA.</p>
<p>This is equal to the inverse lattice spacing 1/d_hkl.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.cart_coord_x">
<tt class="descname">cart_coord_x</tt><big>(</big><em>uc_x</em>, <em>uc_y</em>, <em>uc_z</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.cart_coord_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the x-coord in the cart system</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.cart_coord_y">
<tt class="descname">cart_coord_y</tt><big>(</big><em>uc_x</em>, <em>uc_y</em>, <em>uc_z</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.cart_coord_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the y-coord in the cart system</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.cart_coord_z">
<tt class="descname">cart_coord_z</tt><big>(</big><em>uc_x</em>, <em>uc_y</em>, <em>uc_z</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.cart_coord_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the y-coord in the cart system</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.cart_coords">
<tt class="descname">cart_coords</tt><big>(</big><em>uc_x</em>, <em>uc_y</em>, <em>uc_z</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.cart_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the uc coors uc_x, uc_y, uc_z to cartesian
coordinates expressed in AA</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.dist">
<tt class="descname">dist</tt><big>(</big><em>x1</em>, <em>y1</em>, <em>z1</em>, <em>x2</em>, <em>y2</em>, <em>z2</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the distance in AA between the points
(x1, y1, z1) and (x2, y2, z2). The coords has to be unit cell
coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_a">
<tt class="descname">set_a</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_alpha">
<tt class="descname">set_alpha</tt><big>(</big><em>alpha</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_alpha" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_b">
<tt class="descname">set_b</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_beta">
<tt class="descname">set_beta</tt><big>(</big><em>beta</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_beta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_c">
<tt class="descname">set_c</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.set_gamma">
<tt class="descname">set_gamma</tt><big>(</big><em>gamma</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.set_gamma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd.UnitCell.vol">
<tt class="descname">vol</tt><big>(</big><big>)</big><a class="headerlink" href="#genx.models.sxrd.UnitCell.vol" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the volume of the unit cell in AA**3</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="genx.models.sxrd.scale_sim">
<tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">scale_sim</tt><big>(</big><em>data</em>, <em>sim_list</em>, <em>scale_func=None</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.scale_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the data according to a miminimazation of
sum (data-I_list)**2</p>
</dd></dl>

<dl class="function">
<dt id="genx.models.sxrd.scale_sqrt_sim">
<tt class="descclassname">genx.models.sxrd.</tt><tt class="descname">scale_sqrt_sim</tt><big>(</big><em>data</em>, <em>sim_list</em>, <em>scale_func=None</em><big>)</big><a class="headerlink" href="#genx.models.sxrd.scale_sqrt_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale the data according to a miminimazation of
sum (sqrt(data)-sqrt(I_list))**2</p>
</dd></dl>

</div>
<div class="section" id="module-genx.models.sxrd_mult">
<span id="genx-models-sxrd-mult-module"></span><h2>genx.models.sxrd_mult module<a class="headerlink" href="#module-genx.models.sxrd_mult" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt;Library for surface x-ray diffraction simulations of superlattices&lt;/h1&gt;
&lt;p&gt; The model is based on Fullertons algorithm for superlattices as
described in Phys. Rev. B vol. 45 p. 9292 (1992).</p>
<dl class="class">
<dt id="genx.models.sxrd_mult.SLSample">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd_mult.</tt><tt class="descname">SLSample</tt><big>(</big><em>inst</em>, <em>bulk_slab</em>, <em>superlattice</em>, <em>unitcell</em>, <em>bulk_sym=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that models a multilayer sample on top of a 
substrate according to Fullertons model as given in
PRB ....</p>
<dl class="method">
<dt id="genx.models.sxrd_mult.SLSample.calc_fb">
<tt class="descname">calc_fb</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample.calc_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors from the bulk</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLSample.calc_i">
<tt class="descname">calc_i</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample.calc_i" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the diffracted intensity from a superlattice.
The diffracted intensity from the superlattice and the substrate
are added. I.e. it is assumed that the films is not coherent with
the substrate.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLSample.set_bulk_slab">
<tt class="descname">set_bulk_slab</tt><big>(</big><em>bulk_slab</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample.set_bulk_slab" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the bulk unit cell to bulk_slab</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLSample.set_bulk_sym">
<tt class="descname">set_bulk_sym</tt><big>(</big><em>sym_list</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample.set_bulk_sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the list of allowed symmetry operations for the bulk</p>
<p>sym_list has to be a list ([]) of symmetry elements from the
class SymTrans</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLSample.set_unit_cell">
<tt class="descname">set_unit_cell</tt><big>(</big><em>unit_cell</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLSample.set_unit_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the unitcell of the sample</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd_mult.SLStandard">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd_mult.</tt><tt class="descname">SLStandard</tt><big>(</big><em>inst</em>, <em>unit_cell</em>, <em>a_slab</em>, <em>b_slab</em>, <em>a_sym=</em>, <span class="optional">[</span><span class="optional">]</span><em>b_sym=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLStandard" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#genx.models.sxrd_mult.Superlattice" title="genx.models.sxrd_mult.Superlattice"><tt class="xref py py-class docutils literal"><span class="pre">genx.models.sxrd_mult.Superlattice</span></tt></a></p>
<p>Class that implements a &#8220;standard&#8221; superlattice, no strain 
included.</p>
<dl class="method">
<dt id="genx.models.sxrd_mult.SLStandard.calc_fa">
<tt class="descname">calc_fa</tt><big>(</big><em>n</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLStandard.calc_fa" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLStandard.calc_fb">
<tt class="descname">calc_fb</tt><big>(</big><em>n</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLStandard.calc_fb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLStandard.calc_i">
<tt class="descname">calc_i</tt><big>(</big><em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLStandard.calc_i" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the form factor from a superlattice</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.SLStandard.thick_prob">
<tt class="descname">thick_prob</tt><big>(</big><em>n_mean</em>, <em>stand_dev</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.SLStandard.thick_prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="genx.models.sxrd_mult.Superlattice">
<em class="property">class </em><tt class="descclassname">genx.models.sxrd_mult.</tt><tt class="descname">Superlattice</tt><big>(</big><em>inst</em>, <em>unit_cell</em>, <em>a_slab</em>, <em>b_slab</em>, <em>a_sym=</em>, <span class="optional">[</span><span class="optional">]</span><em>b_sym=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.Superlattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Class that describe a superlattice, can be subclassed
to implement different strain profiles, interdiffusion etc..</p>
<dl class="method">
<dt id="genx.models.sxrd_mult.Superlattice.calc_fa">
<tt class="descname">calc_fa</tt><big>(</big><em>n</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.Superlattice.calc_fa" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the strucutre factor for a a layer
n is the thickness of the bilayer in units of slabs</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.Superlattice.calc_fb">
<tt class="descname">calc_fb</tt><big>(</big><em>n</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.Superlattice.calc_fb" title="Permalink to this definition">¶</a></dt>
<dd><p>Calcualte the structure factor for a b layer
n is the thickness of the bilayer in units of slabs</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.Superlattice.calc_fsl">
<tt class="descname">calc_fsl</tt><big>(</big><em>unit_cell</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.Superlattice.calc_fsl" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the strucutre factor for the entire 
superlattice.</p>
</dd></dl>

<dl class="method">
<dt id="genx.models.sxrd_mult.Superlattice.calc_fslab">
<tt class="descname">calc_fslab</tt><big>(</big><em>slablist</em>, <em>sym</em>, <em>h</em>, <em>k</em>, <em>l</em><big>)</big><a class="headerlink" href="#genx.models.sxrd_mult.Superlattice.calc_fslab" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure factors from the bulk</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-genx.models.utils">
<span id="genx-models-utils-module"></span><h2>genx.models.utils module<a class="headerlink" href="#module-genx.models.utils" title="Permalink to this headline">¶</a></h2>
<p>&lt;h1&gt;Utilities for GenX and scattering&lt;/h1&gt;
This library contains nice to have functions and classes. Most noteworthy
is the UserVars class. The scattering factor tables can also come handy.</p>
<p>&lt;h2&gt;Classes&lt;/h2&gt;</p>
<p>&lt;h3&gt;UserVars&lt;/h3&gt;
This class is used to contain user defined variables which is problem specific
and do not warrant a completly new model library.
It is contstructed as: &lt;code&gt;vars = UserVars()&lt;/code&gt;.&lt;br&gt;
A new variable is created by calling the new_var method: 
&lt;code&gt;vars.new_var(&#8216;my_var&#8217;, 10.0)&lt;/code&gt;&lt;br&gt;
The methods in this class are:
&lt;dl&gt;</p>
<blockquote>
<div>&lt;dt&gt;&lt;code&gt;&lt;b&gt;__init__(self)&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Create a new variable container&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;&lt;b&gt;new_var(self, name, value)&lt;/b&gt;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Create a new varaible with name [string] name and value value [float]
&lt;/dd&gt;</div></blockquote>
<p>&lt;/dl&gt;
The created varaibles are accesed through the as [Uservars].set[Name] and
[Uservars].get[Name]. In the example above this would read:</p>
<blockquote>
<div>&lt;code&gt;vars.setMy_var(20)&lt;/code&gt; to set a value and</div></blockquote>
<p>&lt;code&gt;vars.getMy_vars()&lt;/code&gt; to retrieve the value.</p>
<p>&lt;h3&gt;Scattering factor databases&lt;/h3&gt;
The following databases exist in GenX. All databases are accesed through
&lt;code&gt;[name].[element]&lt;/code&gt; for example: &lt;code&gt;fp.fe&lt;/code&gt;</p>
<p>&lt;h4&gt;fp&lt;/h4&gt;
The fp contains the scattering factors at Q = 0 for the 92 first elements up
to U in units of electrons or more precise Thompson scattering lengths. 
The data is taken from &lt;a href = &#8220;<a class="reference external" href="http://henke.lbl.gov/optical_constants/asf.html">http://henke.lbl.gov/optical_constants/asf.html</a>&#8220;&gt;
<a class="reference external" href="http://henke.lbl.gov/optical_constants/asf">http://henke.lbl.gov/optical_constants/asf</a>.html&lt;/a&gt;. These tables are also 
known as the henke tables. According to
cxros homepage: 
There are 500+ points on a uniform logarithmic mesh from 
10 to 30,000 eV with points added 0.1 eV above and 
below &#8220;sharp&#8221; absorption edges. For some elements data on a 
finer mesh includes structure around absorption edges. 
(Below 29 eV f1 is set equal to -9999.)</p>
<p>&lt;h4&gt;bc&lt;/h4&gt;
The bc data base contains the coherent scattering length for neutrons according
to the data published in Neutron News, Vol. 3, No. 3, 1992, pp.  29-37.
The data file is taken from the Dabax library compiled by esrf
&lt;a href = &#8220;<a class="reference external" href="http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles/">http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles/</a>&#8220;&gt;
<a class="reference external" href="http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles">http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles</a>/&lt;/a&gt;.
To use isotopes just add &#8220;i&#8221; in front of the name i.e., bc.i57Fe.</p>
<p>&lt;h4&gt;f&lt;/h4&gt;
The f database contains the &lt;em&gt;scattering vector dependent&lt;/em&gt; isotropic
scattering factors in electrons or more precise Thompson scattering lengths.
The data is taken from the fp and the f0 database.</p>
<p>&lt;h4&gt;f0&lt;/h4&gt;
The f0 database contains the &lt;em&gt;scattering vector dependent&lt;/em&gt; isotropic
scattering factors in electrons or more precise Thompson scattering lengths.
The data is the so-called Croemer-Mann tables see:
International Tables vol. 4 or vol C; in vol. C refer to pg 500-502.</p>
<blockquote>
<div>Note, this is only good out to sin(theta)/lambda &lt; 2.0 [Angstrom^-1].</div></blockquote>
<p>The data is also fetched from the Dabax library at:
&lt;a href = &#8220;<a class="reference external" href="http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles/">http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles/</a>&#8220;&gt;
<a class="reference external" href="http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles">http://ftp.esrf.eu/pub/scisoft/xop2.3/DabaxFiles</a>/&lt;/a&gt;
This database is the non-dispersive (without resonant contribution).</p>
<p>&lt;h4&gt;fw&lt;/h4&gt;
Same thing as f but scaled so that is can be used with a density
in g/cm&lt;sup&gt;3&lt;sup&gt;.</p>
<p>&lt;h4&gt;bw&lt;/h4&gt;
Same thing as bc but scaled so that is can be used with a density
in g/cm&lt;sup&gt;3&lt;sup&gt;.</p>
<dl class="class">
<dt id="genx.models.utils.UserVars">
<em class="property">class </em><tt class="descclassname">genx.models.utils.</tt><tt class="descname">UserVars</tt><a class="headerlink" href="#genx.models.utils.UserVars" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="genx.models.utils.UserVars.newVar">
<tt class="descname">newVar</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#genx.models.utils.UserVars.newVar" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="genx.models.utils.UserVars.new_var">
<tt class="descname">new_var</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#genx.models.utils.UserVars.new_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="genx.models.utils.create_fp">
<tt class="descclassname">genx.models.utils.</tt><tt class="descname">create_fp</tt><big>(</big><em>wavelength</em><big>)</big><a class="headerlink" href="#genx.models.utils.create_fp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.utils.create_fp_old">
<tt class="descclassname">genx.models.utils.</tt><tt class="descname">create_fp_old</tt><big>(</big><em>wavelength</em><big>)</big><a class="headerlink" href="#genx.models.utils.create_fp_old" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="genx.models.utils.create_fw">
<tt class="descclassname">genx.models.utils.</tt><tt class="descname">create_fw</tt><big>(</big><em>wavelength</em><big>)</big><a class="headerlink" href="#genx.models.utils.create_fw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-genx.models">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-genx.models" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">GenX 2.2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Matts Björck.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>